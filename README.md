# pixelsandpetals
Official Website for Pixels &amp; Petals Organization

# **High-level approach (recommended)**

**Monorepo** with shared UI & logic →

- Frontend web: **Next.js (TypeScript)** for SEO, fast pages, SSR/ISR.
- Native mobile: **Expo / React Native (TypeScript)** with **react-native-web** to reuse UI where feasible.
- Shared UI/components: a package used by both Next & Expo (component library with Storybook).
- Backend: **GraphQL (AppSync) or REST (API Gateway + Lambda)** — choose GraphQL/AppSync if you want a single schema-driven API and subscriptions; choose REST + Lambda if you prefer simpler handlers.
- Auth: **AWS Cognito (recommended)** — integrates well with AppSync, Next, and Expo; Hosted UI + OAuth flows. (Auth0 is an alternative.)
- Storage/media: **S3 + CloudFront**.
- DB: **DynamoDB** for scale / serverless; **Aurora Serverless (Postgres)** if you need relational queries/joins.
- Infra as code: **AWS CDK (TypeScript)** or **Serverless Framework** (I prefer CDK for multi-service infra).
- CI/CD: **GitHub Actions** for web & backend; **EAS/Expo build + Fastlane** for stores.

---

# **Why this stack?**

- **Next.js**: best for SEO, pages, image optimization, and hybrid static + server rendering.
- **Expo + react-native-web**: maximizes code reuse — many components and business logic can be shared.
- **Monorepo** (Turborepo or Nx): single place for shared components, consistent build scripts, and faster local dev.
- **AppSync** (GraphQL) or API Gateway + Lambda: scales well and maps cleanly to dynamic content.
- **Cognito**: secure, integrates with AWS infra, supports SSO and social providers.

---

# **Scaffolding commands (quick start — Turborepo + Next + Expo)**

Run these from your machine (assumes Node, corepack installed):

# 1. Create a monorepo

```bash
mkdir pixels-and-petals && cd pixels-and-petals
npm init -y
npm i -D turbo
```

# 2. create apps + packages

```bash
npx create-next-app@latest apps/web --ts
npx create-expo-app apps/mobile --template expo-template-blank-typescript
mkdir packages
cd packages
mkdir ui shared
cd ..
```

# 3. add workspace config (package.json top-level)

```bash
edit package.json: add "workspaces": ["apps/*","packages/*"]
```

(If you prefer Nx, swap turbo for Nx and use npx create-nx-workspace.)

---

# **Recommended repo structure**

```bash
/apps
/web            # Next.js app
/mobile         # Expo React Native app
/packages
/ui             # shared React components (Button, Card, Theme)
/icons
/utils          # shared helpers (api client, auth helpers)
/storybook      # optional
/infrastructure
/cdk            # AWS CDK (TypeScript) — AppSync, Cognito, S3, Lambdas, DynamoDB
.gitignore
package.json
turbo.json
```

---

# **Component sharing tips**

- Build components in packages/ui using React primitives and style with a cross-platform solution: **Tailwind + twrnc / NativeWind** or **styled-components** with platform fallbacks.
- Keep platform-specific code minimal (use Platform.OS or file extensions .native.tsx for RN-specific bits).

---

# **Authentication (Cognito) — flow & snippets**

**Flow**

- Use **Cognito User Pool** for user accounts and **Cognito Identity Pool** for AWS creds if you need direct S3 access.
- Use **Hosted UI (OAuth)** for social logins or **Amplify Auth** for easier integration.
- For web: use **Auth0/Cognito/OIDC** via NextAuth or Amplify. For mobile: use **amazon-cognito-identity-js** or **expo-auth-session** integrated with Cognito Hosted UI.

**Next.js (client-side signin)** — example using Amplify (quick integration):

```bash
install
```

```bash
yarn workspace web add aws-amplify @aws-amplify/ui-react
```

src/aws-exports.js is generated by Amplify CLI or fill using CDK outputs.

pages/_app.tsx:

```bash
import { Amplify } from "aws-amplify";
import awsExports from "../src/aws-exports";
Amplify.configure({...awsExports, ssr: true});
```

Use Auth.signIn() / Auth.federatedSignIn() in your UI.

**Expo mobile** — expo-auth-session with Cognito Hosted UI:

```bash
import * as AuthSession from 'expo-auth-session';
```

```bash
// configure redirectUri and clientId from Cognito
const result = await AuthSession.startAsync({ authUrl: cognitoAuthUrl });
```

(If you want a simpler cross-platform path, consider **Auth0** or **Firebase Auth** — but Cognito ties cleanly to other AWS infra.)

---

# **API design — GraphQL (AppSync) example**

**Why GraphQL**: a single endpoint for web and mobile, built-in subscriptions for real-time updates, and fine-grained data queries.

Sample GraphQL schema (user/profile + content):

```bash
type User @model {
id: ID!
name: String
email: String!
createdAt: AWSDateTime
}
```

```bash
type Post @model {
id: ID!
title: String!
body: String
author: User @connection
createdAt: AWSDateTime
}
```

From Next/Expo, use @aws-amplify/api-graphql or ApolloClient against AppSync.

**REST alternative**: API Gateway → Lambda (Node/TypeScript) with routes:

- POST /auth/login (if using custom auth)
- GET /content/home
- GET /users/:id

Use JWTs from Cognito for auth (passed in Authorization header).

---

# **Data storage**

- **S3** for public assets (images, PDFs). Serve via **CloudFront**.
- **DynamoDB** for content and user metadata (fast, serverless).
- **Aurora Serverless (Postgres)** if you need relational joins, transactions, complex queries.

---

# **Infrastructure as Code (AWS CDK) — minimal outline**

Use CDK to provision Cognito, AppSync, S3, and Lambdas. Example directories: infrastructure/cdk.

Key CDK constructs:

- new cognito.UserPool(...)
- new appsync.GraphqlApi(...)
- new s3.Bucket(...)
- Lambda functions with new lambda.Function(...)

CDK outputs will give you COGNITO_USERPOOL_ID, APPSYNC_API_URL, etc., to fill into frontend env.

---

# **CI/CD & Deployment**

- **Web (Next.js)**: Vercel is easiest (auto-deploy on push) or deploy manually to S3 + CloudFront or AWS Amplify.
- **Mobile (Expo)**: use **EAS Build** for app store binaries; use **EAS Submit** or **Fastlane** for deployments.
- **Backend & infra**: GitHub Actions that run cdk deploy or serverless deploy on merge to main (use least privilege IAM user).
- **Secrets**: use GitHub Secrets for AWS creds, Cognito client secret, App Store keys, etc.

Example GitHub Actions snippet (deploy CDK):

```bash
jobs:
deploy:
runs-on: ubuntu-latest
steps:
- uses: actions/checkout@v4
- uses: aws-actions/configure-aws-credentials@v2
with:
aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
aws-region: us-west-2
- run: cd infrastructure/cdk && npm ci && npm run build && npx cdk deploy --require-approval never
```

---

# **Local dev workflow**

- Use local dev server for Next: yarn workspace web dev
- Expo mobile: yarn workspace mobile start → test in simulator or Expo Go.
- For AWS services locally: use **LocalStack** or mock with environment feature flags. For AppSync, mock using Apollo local server for unit tests.

---

# **Storybook & Component Testing**

- Add **Storybook** in packages/ui to preview shared components.
- Use **Jest + React Testing Library** for unit tests (configure for both web & RN with @testing-library/react-native).

---

# **Example: Calling your API from Next.js & Expo (shared client)**

Create a shared packages/utils/apiClient.ts:

```bash
// packages/utils/apiClient.ts
import axios from 'axios';
```

```bash
const api = axios.create({
baseURL: process.env.NEXT_PUBLIC_API_URL,
});
```

```bash
export const fetchHome = () => api.get('/content/home').then(r => r.data);
export const getUser = (id: string) => api.get(/users/${id}).then(r => r.data);
```

In Next.js:

```bash
import { fetchHome } from 'utils/apiClient';
export async function getServerSideProps() {
const data = await fetchHome();
return { props: { data } };
}
```

In Expo:

```bash
import { fetchHome } from 'utils/apiClient';
useEffect(() => { fetchHome().then(setData) }, []);
```

Remember to store NEXT_PUBLIC_API_URL in environment variables (GitHub Secrets / hosting env).

---

# **Authentication snippet (use JWT from Cognito)**

After sign-in, include token in requests:

```bash
// utils/authClient.ts
export function authHeader(token?: string) {
return { headers: { Authorization: Bearer ${token} } };
}
```

```bash
// usage
api.get('/users/me', authHeader(await getCognitoToken()));
```

---

# **Security & best practices**

- Never commit .env — use GitHub Secrets and hosting env variables.
- Protect private API routes by validating JWTs (Cognito provides RS256 keys you can validate).
- Use HTTPS, set security headers (CSP), enable S3 bucket policies and CloudFront.
- Implement rate limiting on APIs if they are public.
- Use least-privilege IAM roles for Lambdas.

---

# **Testing the native integration**

- Test webview/native bridging if your app uses WebView (you earlier asked about postMessage) — add a small test page that communicates with native side using window.ReactNativeWebView.postMessage.

---

# **Offline-first / caching (optional)**

- Use **Apollo cache** for GraphQL or **SWR/React Query** for REST to cache and revalidate data.
- For mobile offline sync, consider **AppSync offline capabilities** or add local DB (WatermelonDB / Realm).

---

# **Deliverables I can prepare for you (pick any; I’ll provide full files/snippets)**

- Monorepo scaffold commands + package.json + turbo.json config.
- packages/ui starter component + Storybook config.
- apps/web Next.js sample page that uses the shared apiClient.
- apps/mobile Expo sample screen that uses same shared components + API client.
- Minimal AWS CDK stack that provisions Cognito + AppSync + S3.
- GitHub Actions workflow templates for deploying web & infra.
- Expo EAS / Fastlane config for building & submitting to stores.

(If you want any of the above, tell me which one and I’ll paste the exact files/commands to copy into your repo.)

---

# **Quick checklist to get started right now**

1. Create Git repo and set up workspaces in package.json.
2. Scaffold Next app + Expo app + packages/ui.
3. Wire Turborepo/Nx cache and scripts (dev, build, lint, test).
4. Provision initial AWS infra with CDK (Cognito + S3 + simple AppSync or Lambda).
5. Implement auth flows (Cognito Hosted UI for web; Expo AuthSession for mobile).
6. Build a few core screens from Figma: Login, Home feed (dynamic), Profile, Settings.
7. Add Storybook & tests for shared UI.
8. Configure GitHub Actions and EAS for CI/CD.
9. Deploy web to Vercel or S3+CloudFront and build mobile binaries via EAS.
